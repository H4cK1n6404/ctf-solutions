# BSides Dehli CTF 2018: RSABaby (Crypto 100)

__Tags:__ `crypto`, `rsa`  
__Total Points:__ 100

## Problem Statement

### encrypt.py
The implementation of `encrypt.py` is short enough for us to fully show here.

```python
from Crypto.Util.number import *
from secret import flag

modulus_list = [143786356117385195355522728814418684024129402954309769186869633376407480449846714776247533950484109173163811708549269029920405450237443197994941951104068001708682945191370596050916441792714228818475059839352105948003874426539429621408867171203559281132589926504992702401428910240117807627890055235377744541913L,
 73988726804584255779346831019194873108586184186524793132656027600961771331094234332693404730437468912329694216269372797532334390363774803642809945268154324370355113538927414351037561899998734391507272602074924837440885467211134022878597523920836541794820777951492188067045604789153534513271406458984968338509L,
 95666403279611361071535593067846981517930129087906362381453835849857496766736720885263927273295086034390557353492037703154353541274448884795437287235560639118986397838850340017834752502157881329960725771502503917735194236743345777337851076649842634506339513864285786698870866229339372558162315435127197444193L,
 119235191922699211973494433973985286182951917872084464216722572875998345005104112625024274855529546680909781406076412741844254205002739352725207590519921992295941563460138887173402493503653397592300336588721082590464192875253265214253650991510709511154297580284525736720396804660126786258245028204861220690641L]

e = [114194L, 130478L, 122694L, 79874L]
message = bytes_to_long(flag)
ciphertext = [pow(message, e[i], modulus_list[i]) for i in range(4)]
ciphertext = [long_to_bytes(ciphertext[i]) for i in range(4)]
ciphertext = [ciphertext[i].encode("hex") for i in range(4)]

obj1 = open("ciphertext.txt",'w')
obj1.write(str(ciphertext))
```

## Solution

The encryption shows encrypting the same ciphertext with different pairs for `N` and `e`. Luckily, looking at the first encryption pair is sufficient to get the flag.

### Analyzing N1 and e1

We get the values for `n`, `e` and `ciphertext` from `encrypt.py`  and `ciphertext.txt`

```python
n = 143786356117385195355522728814418684024129402954309769186869633376407480449846714776247533950484109173163811708549269029920405450237443197994941951104068001708682945191370596050916441792714228818475059839352105948003874426539429621408867171203559281132589926504992702401428910240117807627890055235377744541913
e = 114194
ciphertext = 0x0c55bc89e3773d8e378121eced4f9300103a8696bc3f9a1542c5b1539442ca5de03a40ad564ab5c2e764b2f946058ec220abf20afc271896ff4ca1f4a2dd227405f221de51e097d6b9f270c4561cd25596e96efd7de1a0e65d37cbf6a73c62a7e323f48450b9dc75e3e738ec1c7e1ae9fc808da8c476e72aea9155125b815653
```

Luckily, the factorization for this is known in [factordb](http://factordb.com/index.php?query=143786356117385195355522728814418684024129402954309769186869633376407480449846714776247533950484109173163811708549269029920405450237443197994941951104068001708682945191370596050916441792714228818475059839352105948003874426539429621408867171203559281132589926504992702401428910240117807627890055235377744541913).

```python
p = 11196022518013846406450257763680307528861440840633712357021019120934410373180406217919066924474450204377977943388931820832436504741695416094988192576484719
q = n/p
assert n == p*q
```

### Decrypting

When constructing `d`, we notice the `phi(n)` and `e` are not coprime, __with gcd of 2__.

Instead we get the mod inverse `d = inverse(e/2, phi)` so that `(e*d)%phi == 2`.

```python
phi = (p-1)*(q-1)
g = GCD(e, phi)
assert g == 2

d = inverse(e/g, phi)
assert (e*d)%phi == g
```

So when decrypting the ciphertext with `d`, what we actually get is `flag^2`. Since this is textbook RSA, and the flag is sufficiently small, that we just get the square root.

```python
plaintext_squared = pow(ciphertext, d, n)
print(long_to_bytes(gmpy2.isqrt(plaintext_squared)))
```

This gives us the flag `flag{Congratzzz_y0u_kn0w_ext3nded_GCD_WOw!!}`

## Full Solution

```python
from Crypto.Util.number import *
import gmpy2
n = 143786356117385195355522728814418684024129402954309769186869633376407480449846714776247533950484109173163811708549269029920405450237443197994941951104068001708682945191370596050916441792714228818475059839352105948003874426539429621408867171203559281132589926504992702401428910240117807627890055235377744541913
e = 114194
ciphertext = 0x0c55bc89e3773d8e378121eced4f9300103a8696bc3f9a1542c5b1539442ca5de03a40ad564ab5c2e764b2f946058ec220abf20afc271896ff4ca1f4a2dd227405f221de51e097d6b9f270c4561cd25596e96efd7de1a0e65d37cbf6a73c62a7e323f48450b9dc75e3e738ec1c7e1ae9fc808da8c476e72aea9155125b815653

p = 11196022518013846406450257763680307528861440840633712357021019120934410373180406217919066924474450204377977943388931820832436504741695416094988192576484719
q = n/p
assert n == p*q

phi = (p-1)*(q-1)
g = GCD(e, phi)
assert g == 2

d = inverse(e/g, phi)
assert (e*d)%phi == g

plaintext_squared = pow(ciphertext, d, n)
print(long_to_bytes(gmpy2.isqrt(plaintext_squared)))
```
